# -*- coding: utf-8 -*-
"""程式競賽_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hwiEYQB_nIDcJMd3h-DxjY-6CgVMD3-3

# 預測電力 2020/03/28
"""

#Colab資料夾設定方法
#!pip install google.colab #如未安裝取消註解後執行
#import os

#from google.colab import drive
#drive.mount('/content/drive')

#os.chdir('/content/drive/MyDrive/程式競賽/預測台電') #改變當前工作目錄到指定的路徑
#os.listdir() #確認目錄內容

#載入庫
from sklearn import datasets
from sklearn import linear_model
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error 
from math import sqrt
import argparse
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Output the value of the operating reserve value of each day during 2022/03/30 ~ 2022/04/13.
def OutPut_Data(pred):
    name = ['operating reserv(MW)']
    pred = pd.DataFrame(pred, columns=name)
    date = [['date'],['2022/3/30'],['2022/3/31'],['2022/4/01'],
            ['2022/4/02'],['2022/4/03'],['2022/4/04'],['2022/4/05']
            ,['2022/4/06'],['2022/4/07'],['2022/4/08'],['2022/4/09']
            ,['2022/4/10'],['2022/4/11'],['2022/4/12'],['2022/4/13']]
    name = date.pop(0)
    date_df = pd.DataFrame(date,columns=name)
    res = pd.concat([date_df,pred],axis = 1)
    res.to_csv(args.output,index=0)

# Preprocess data,in case to gain a error dataset
def PreProcess_Data(df):
    # 找資料相關性
    corr = df.corr()

    # The number of columns to be displayed in the heat map
    k = 5
    # Calculate for the top 5 columns with the highest correlation with operating reserve
    cols = corr.nlargest(k, 'operating reserve')['operating reserve'].index
    # print(cols)

    # 刪除離群資料，降低RMSE
    df = df.drop(index=df.sort_values(by='rate', ascending=False)['date'][:20].index)
    df = df.drop(index=df.sort_values(by='people_use', ascending=False)['date'][:20].index)
    df = df.drop(index=df.sort_values(by='ele_pro', ascending=False)['date'][:20].index)
    df = df.drop(index=df.sort_values(by='sun', ascending=False)['date'][:20].index)
    sns.pairplot(df[cols], size=1.2)
    return df

def predict_power():
    # 載入訓練資料集
    df = pd.read_csv('train.csv')
    df = PreProcess_Data(df)

    # 建立資料
    x = pd.DataFrame(df[['rate', 'people_use', 'ele_pro', 'sun']])
    # print("target_names: "+str(df[['rate', 'people_use','ele_pro', 'sun']]))
    y = pd.DataFrame(df['operating reserve'], columns=['operating reserve'])
    df_data = pd.concat([x, y], axis=1)
    df_data.head(3)

    # 使用Linear Regression之前需要先對資料做特徵縮放
    sc = StandardScaler()
    sc.fit(x)
    X_train_std = sc.transform(x)

    # 初始化Linear Regression函式，以及將資料放進Linear Regression開始訓練
    model = linear_model.LinearRegression()
    model.fit(X_train_std, y['operating reserve'].values)

    # 載入測試資料集
    df = pd.read_csv('test.csv')
    test_x = pd.DataFrame(df[['rate', 'people_use', 'ele_pro', 'sun']][-15:])
    print("target_names: " + str(df[['rate', 'people_use', 'ele_pro', 'sun']][-15:]))
    test_y = pd.DataFrame(df['operating reserve'][-15:], columns=['operating reserve'])
    # print(test_x)
    # print(test_y)

    # 使用Linear Regression之前需要先對資料做特徵縮放
    test_sc = StandardScaler()
    test_sc.fit(test_x)
    X_test_std = test_sc.transform(test_x)

    # 預測結果
    model.predict(X_test_std)

    # 驗證資料
    test_y['operating reserve'].values

    plt.scatter(model.predict(X_test_std), test_y['operating reserve'].values, color='black')
    # 計算RMSE，確認預測準確度

    error = sqrt(mean_squared_error(test_y, model.predict(X_test_std)))  # calculate rmse
    print("RMSE:", error)

    # 輸出預測結果
    OutPut_Data(model.predict(X_test_std))

#main
if __name__ =='__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--training',
                        default='train.csv',
                        help='input training data file name')
    parser.add_argument('--output',
                        default='submission.csv',
                        help='output file name')
    args = parser.parse_args()
    predict_power()
